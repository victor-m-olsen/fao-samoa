{"file_contents":{"app.py":{"content":"import streamlit as st\nimport sqlite3\nfrom database.db_setup import init_database\n\n# Initialize database on startup\ninit_database()\n\nst.set_page_config(page_title=\"Instructions - Agricultural Management System\",\n                   page_icon=\"📋\",\n                   layout=\"wide\")\n\n# Page namespace and state cleanup\nPAGE_PREFIX = \"instructions\"\nk = lambda name: f\"{PAGE_PREFIX}:{name}\"\n\ndef cleanup_foreign_keys(current_page):\n    \"\"\"Remove session state keys from other pages to prevent UI bleeding\"\"\"\n    keys_to_delete = []\n    for key in st.session_state.keys():\n        if isinstance(key, str) and \":\" in key:\n            if not key.startswith(f\"{current_page}:\"):\n                keys_to_delete.append(key)\n    \n    for key in keys_to_delete:\n        del st.session_state[key]\n\n# Clean up state from other pages\ncleanup_foreign_keys(PAGE_PREFIX)\n\nst.title(\"📋 Instructions\")\nst.markdown(\"\"\"\nWelcome to the Cropland Registration System! This application helps you:\n\n- 🌾 **Register Crop Production**: Key crop information such a crop type, planting material sources and yield\n- 🗺️ **Register Field Boundaries**: Draw field boundaries for each crop type on an interactive map\n- 📊 **View Data**: View and download all collected survey data and field boundaries\n\n\n\"\"\")\n\nst.markdown(\"\"\"\n---\n**Instructions:**\n1. Use the **Register Crops** page to enter production data and map field boundaries for each crop type.\n2. Review all collected data and insights in the **View Data** page\n\"\"\")\n","size_bytes":1503},"database_viewer.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nDatabase viewer and editor for agricultural_data.db\nProvides functions to view, query, and modify the SQLite database\n\"\"\"\n\nimport sqlite3\nimport json\nimport pandas as pd\nfrom datetime import datetime\n\ndef view_tables():\n    \"\"\"Show all tables in the database\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    cursor = conn.cursor()\n    \n    cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table';\")\n    tables = cursor.fetchall()\n    \n    print(\"Available tables:\")\n    for table in tables:\n        print(f\"- {table[0]}\")\n        \n        # Get row count\n        cursor.execute(f\"SELECT COUNT(*) FROM {table[0]}\")\n        count = cursor.fetchone()[0]\n        print(f\"  Rows: {count}\")\n        \n        # Show column structure\n        cursor.execute(f\"PRAGMA table_info({table[0]})\")\n        columns = cursor.fetchall()\n        print(f\"  Columns: {[col[1] for col in columns]}\")\n        print()\n    \n    conn.close()\n\ndef view_form_responses(limit=5):\n    \"\"\"View recent form responses\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    \n    query = f\"\"\"\n    SELECT id, farmer_id, district, village, crop_type, submission_date \n    FROM form_responses \n    ORDER BY submission_date DESC \n    LIMIT {limit}\n    \"\"\"\n    \n    df = pd.read_sql_query(query, conn)\n    conn.close()\n    \n    print(f\"Recent {limit} form responses:\")\n    print(df.to_string(index=False))\n    return df\n\ndef view_field_boundaries(limit=5):\n    \"\"\"View recent field boundaries\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    \n    query = f\"\"\"\n    SELECT id, farmer_id, field_name, field_type, crop_type, area_estimate, creation_date\n    FROM field_boundaries \n    ORDER BY creation_date DESC \n    LIMIT {limit}\n    \"\"\"\n    \n    df = pd.read_sql_query(query, conn)\n    conn.close()\n    \n    print(f\"Recent {limit} field boundaries:\")\n    print(df.to_string(index=False))\n    return df\n\ndef search_by_farmer_id(farmer_id):\n    \"\"\"Find all records for a specific farmer\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    \n    # Form responses\n    print(f\"Form responses for farmer {farmer_id}:\")\n    form_query = \"SELECT * FROM form_responses WHERE farmer_id = ?\"\n    form_df = pd.read_sql_query(form_query, conn, params=(farmer_id,))\n    print(form_df.to_string(index=False))\n    print()\n    \n    # Field boundaries\n    print(f\"Field boundaries for farmer {farmer_id}:\")\n    field_query = \"SELECT * FROM field_boundaries WHERE farmer_id = ?\"\n    field_df = pd.read_sql_query(field_query, conn, params=(farmer_id,))\n    print(field_df.to_string(index=False))\n    \n    conn.close()\n    return form_df, field_df\n\ndef execute_custom_query(query):\n    \"\"\"Execute a custom SQL query\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    \n    try:\n        if query.strip().upper().startswith('SELECT'):\n            df = pd.read_sql_query(query, conn)\n            print(\"Query results:\")\n            print(df.to_string(index=False))\n            return df\n        else:\n            cursor = conn.cursor()\n            cursor.execute(query)\n            conn.commit()\n            print(f\"Query executed successfully. Rows affected: {cursor.rowcount}\")\n    except Exception as e:\n        print(f\"Error executing query: {e}\")\n    finally:\n        conn.close()\n\ndef delete_record(table, record_id):\n    \"\"\"Delete a record by ID\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    cursor = conn.cursor()\n    \n    try:\n        cursor.execute(f\"DELETE FROM {table} WHERE id = ?\", (record_id,))\n        conn.commit()\n        print(f\"Deleted record {record_id} from {table} table. Rows affected: {cursor.rowcount}\")\n    except Exception as e:\n        print(f\"Error deleting record: {e}\")\n    finally:\n        conn.close()\n\ndef backup_database():\n    \"\"\"Create a backup of the database\"\"\"\n    import shutil\n    backup_name = f\"agricultural_data_backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}.db\"\n    shutil.copy2('agricultural_data.db', backup_name)\n    print(f\"Database backed up to: {backup_name}\")\n    return backup_name\n\ndef main():\n    print(\"=== Agricultural Database Viewer ===\")\n    print(\"Database file: agricultural_data.db\")\n    print()\n    \n    while True:\n        print(\"\\nOptions:\")\n        print(\"1. View all tables\")\n        print(\"2. View recent form responses\")\n        print(\"3. View recent field boundaries\") \n        print(\"4. Search by farmer ID\")\n        print(\"5. Execute custom SQL query\")\n        print(\"6. Delete record\")\n        print(\"7. Backup database\")\n        print(\"8. Exit\")\n        \n        choice = input(\"\\nSelect option (1-8): \").strip()\n        \n        if choice == '1':\n            view_tables()\n        elif choice == '2':\n            limit = input(\"How many records to show? (default 5): \").strip()\n            limit = int(limit) if limit.isdigit() else 5\n            view_form_responses(limit)\n        elif choice == '3':\n            limit = input(\"How many records to show? (default 5): \").strip()\n            limit = int(limit) if limit.isdigit() else 5\n            view_field_boundaries(limit)\n        elif choice == '4':\n            farmer_id = input(\"Enter farmer ID: \").strip()\n            if farmer_id:\n                search_by_farmer_id(farmer_id)\n        elif choice == '5':\n            query = input(\"Enter SQL query: \").strip()\n            if query:\n                execute_custom_query(query)\n        elif choice == '6':\n            table = input(\"Enter table name (form_responses/field_boundaries): \").strip()\n            record_id = input(\"Enter record ID to delete: \").strip()\n            if table and record_id.isdigit():\n                confirm = input(f\"Really delete record {record_id} from {table}? (y/N): \")\n                if confirm.lower() == 'y':\n                    delete_record(table, int(record_id))\n        elif choice == '7':\n            backup_database()\n        elif choice == '8':\n            break\n        else:\n            print(\"Invalid option. Please try again.\")\n\nif __name__ == \"__main__\":\n    main()","size_bytes":6018},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"folium>=0.20.0\",\n    \"streamlit-folium>=0.25.1\",\n    \"streamlit>=1.48.1\",\n    \"plotly>=6.3.0\",\n    \"pandas>=2.3.1\",\n]\n","size_bytes":265},"quick_db_commands.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nQuick database commands for common operations\n\"\"\"\n\nimport sqlite3\nimport pandas as pd\n\n# Quick examples for common database operations:\n\ndef show_all_farmers():\n    \"\"\"Show unique farmer IDs\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    df = pd.read_sql_query(\"SELECT DISTINCT farmer_id FROM form_responses ORDER BY farmer_id\", conn)\n    conn.close()\n    print(\"All farmer IDs:\")\n    print(df['farmer_id'].tolist())\n\ndef count_records():\n    \"\"\"Show record counts\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    \n    # Count form responses\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT COUNT(*) FROM form_responses\")\n    form_count = cursor.fetchone()[0]\n    \n    cursor.execute(\"SELECT COUNT(*) FROM field_boundaries\")\n    field_count = cursor.fetchone()[0]\n    \n    conn.close()\n    \n    print(f\"Form responses: {form_count}\")\n    print(f\"Field boundaries: {field_count}\")\n\ndef show_recent_data():\n    \"\"\"Show 3 most recent records from each table\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    \n    print(\"=== Recent Form Responses ===\")\n    form_df = pd.read_sql_query(\"\"\"\n        SELECT id, farmer_id, district, village, crop_type, submission_date \n        FROM form_responses \n        ORDER BY submission_date DESC LIMIT 3\n    \"\"\", conn)\n    print(form_df.to_string(index=False))\n    \n    print(\"\\n=== Recent Field Boundaries ===\")\n    field_df = pd.read_sql_query(\"\"\"\n        SELECT id, farmer_id, field_name, crop_type, area_estimate, creation_date\n        FROM field_boundaries \n        ORDER BY creation_date DESC LIMIT 3\n    \"\"\", conn)\n    print(field_df.to_string(index=False))\n    \n    conn.close()\n\nif __name__ == \"__main__\":\n    print(\"=== Database Quick View ===\")\n    count_records()\n    print()\n    show_recent_data()\n    print()\n    show_all_farmers()","size_bytes":1838},"replit.md":{"content":"# Agricultural Management System\n\n## Overview\n\nThis is a web-based Agricultural Management System built with Streamlit that provides farmers and agricultural professionals with tools to collect survey data, map field boundaries, and view comprehensive dashboards. The system focuses on three main functionalities: form-based data collection for agricultural surveys, interactive field boundary mapping using satellite imagery, and data visualization through analytical dashboards. The application is designed to help agricultural stakeholders digitize their operations, track farm metrics, and gain insights from collected data.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n**Frontend Framework**: Built using Streamlit, providing a multi-page web application with an intuitive navigation structure. The application uses Streamlit's native components for forms, maps, and data visualization.\n\n**Page Structure**: Organized as a multi-page application with:\n- Main landing page (`app.py`) displaying system overview and basic statistics\n- Register Production page for multi-crop agricultural data entry with instant-response form sections\n- Register Plot Boundaries page for interactive boundary drawing on satellite maps centered on Upolu Island, Samoa\n- Dashboard page for data visualization and analytics with field boundaries map\n\n**Database Design**: Uses SQLite as the local database with two main tables:\n- `form_responses`: Stores dynamic crop-specific agricultural data with flexible JSON structure for crop-specific fields (Coconut, Cocoa, Breadfruit, Banana, Kava, Other)\n- `field_boundaries`: Stores geographical field boundary data with coordinates, area estimates, and field metadata\n\n**Form Structure**: Implements instant-response multi-crop checkbox selection with dynamic form sections that appear immediately when crops are selected. Features common identification fields (farmer_id, district, village, EA code, season_year) and crop-specific sections including growth modes, planting sources, age groups, and production data. Multiple crops can be selected simultaneously with separate production tracking for each crop.\n\n**Geographic Focus**: Application is configured for Upolu Island, Samoa (-13.9167, -171.7500) as the Area of Interest (AOI) for agricultural data collection.\n\n**Data Validation**: Implements a centralized validation system (`utils/validators.py`) that ensures data integrity for form submissions, including field requirements, data type validation, and business rule enforcement.\n\n**Mapping Integration**: Incorporates Folium for interactive mapping capabilities, allowing users to draw polygon boundaries on satellite imagery and store geographical coordinates as JSON data.\n\n**Visualization Layer**: Uses Plotly for creating interactive charts and graphs in the dashboard, providing insights into collected agricultural data through various chart types and statistical summaries.\n\n## External Dependencies\n\n**Core Framework**: Streamlit for the web application framework and user interface components\n\n**Database**: SQLite for local data storage and persistence\n\n**Mapping Services**: \n- Folium for interactive map rendering and drawing tools\n- streamlit-folium for Streamlit-Folium integration\n\n**Data Processing**: \n- Pandas for data manipulation and analysis\n- Plotly Express and Plotly Graph Objects for data visualization\n\n**Standard Libraries**: Uses Python standard libraries including sqlite3, json, datetime, and re for core functionality\n\n**Note**: The application is self-contained with minimal external service dependencies, using local SQLite storage and client-side mapping capabilities.","size_bytes":3704},"database/db_setup.py":{"content":"import sqlite3\nimport os\n\n\ndef init_database():\n    \"\"\"Initialize the SQLite database with required tables\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    cursor = conn.cursor()\n\n    # Create form_responses table with flexible JSON structure\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS form_responses (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            farmer_id TEXT NOT NULL,\n            district TEXT NOT NULL,\n            village TEXT NOT NULL,\n            ea_code TEXT,\n            season_year TEXT NOT NULL,\n            crop_type TEXT NOT NULL,\n            form_data TEXT NOT NULL,\n            submission_date TEXT NOT NULL\n        )\n    ''')\n\n    # Create field_boundaries table\n    cursor.execute('''\n        CREATE TABLE IF NOT EXISTS field_boundaries (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            farmer_id TEXT NOT NULL,\n            field_name TEXT NOT NULL,\n            field_type TEXT NOT NULL,\n            crop_type TEXT NOT NULL,\n            coordinates TEXT NOT NULL,\n            area_estimate REAL,\n            notes TEXT,\n            creation_date TEXT NOT NULL\n        )\n    ''')\n\n    conn.commit()\n    conn.close()\n\n\ndef get_database_stats():\n    \"\"\"Get basic statistics about the database\"\"\"\n    try:\n        conn = sqlite3.connect('agricultural_data.db')\n        cursor = conn.cursor()\n\n        cursor.execute(\"SELECT COUNT(*) FROM form_responses\")\n        form_count = cursor.fetchone()[0]\n\n        cursor.execute(\"SELECT COUNT(*) FROM field_boundaries\")\n        field_count = cursor.fetchone()[0]\n\n        conn.close()\n\n        return {\n            'form_responses': form_count,\n            'field_boundaries': field_count,\n            'total_records': form_count + field_count\n        }\n    except Exception as e:\n        return {\n            'error': str(e),\n            'form_responses': 0,\n            'field_boundaries': 0,\n            'total_records': 0\n        }\n\n\ndef clear_all_data():\n    \"\"\"Clear all data from the database (use with caution)\"\"\"\n    try:\n        conn = sqlite3.connect('agricultural_data.db')\n        cursor = conn.cursor()\n\n        cursor.execute(\"DELETE FROM form_responses\")\n        cursor.execute(\"DELETE FROM field_boundaries\")\n\n        conn.commit()\n        conn.close()\n        return True\n    except Exception as e:\n        print(f\"Error clearing database: {str(e)}\")\n        return False\n\n\nif __name__ == \"__main__\":\n    # Initialize database when run directly\n    init_database()\n    print(\"Database initialized successfully!\")\n\n    stats = get_database_stats()\n    print(f\"Database stats: {stats}\")\n","size_bytes":2615},"utils/__init__.py":{"content":"# Utils package for agricultural management system","size_bytes":50},"utils/validators.py":{"content":"import re\n\ndef validate_form_data(data):\n    \"\"\"Validate form data before saving to database\"\"\"\n    errors = []\n    \n    # Required field validation\n    required_fields = {\n        'farmer_id': 'Farmer ID',\n        'district': 'District',\n        'village': 'Village',\n        'season_year': 'Season/Year'\n    }\n    \n    for field, label in required_fields.items():\n        if not data.get(field) or data[field] == \"Select...\" or data[field] == \"\":\n            errors.append(f\"{label} is required\")\n    \n    # Check if at least one crop is selected\n    selected_crops = data.get('selected_crops', [])\n    if not selected_crops:\n        errors.append(\"At least one crop must be selected\")\n    \n    # Specific validation rules\n    if data.get('farmer_id'):\n        if len(data['farmer_id'].strip()) < 3:\n            errors.append(\"Farmer ID must be at least 3 characters long\")\n        if not re.match(r'^[a-zA-Z0-9\\-_]+$', data['farmer_id']):\n            errors.append(\"Farmer ID can only contain letters, numbers, hyphens, and underscores\")\n    \n    if data.get('ea_code'):\n        if not re.match(r'^[0-9]+$', data['ea_code']):\n            errors.append(\"EA Code must contain only numbers\")\n    \n    if data.get('season_year'):\n        if not re.match(r'^\\d{4}/\\d{2,4}$', data['season_year']):\n            errors.append(\"Season/Year must be in format YYYY/YY or YYYY/YYYY (e.g., 2024/25)\")\n    \n    # Crop-specific validation for each selected crop\n    crop_data = data.get('crop_data', {})\n    selected_crops = data.get('selected_crops', [])\n    \n    for crop_type in selected_crops:\n        crop_info = crop_data.get(crop_type, {})\n        \n        # Validate crop-specific required fields\n        if crop_type == \"Coconut\":\n            if crop_info.get('growth_mode') == \"Select...\":\n                errors.append(f\"Growth mode is required for {crop_type}\")\n        elif crop_type == \"Cocoa\":\n            if crop_info.get('growth_mode') == \"Select...\":\n                errors.append(f\"Growth mode is required for {crop_type}\")\n        elif crop_type == \"Breadfruit\":\n            if crop_info.get('growth_mode') == \"Select...\":\n                errors.append(f\"Growth mode is required for {crop_type}\")\n        elif crop_type == \"Banana\":\n            if crop_info.get('banana_type') == \"Select...\":\n                errors.append(f\"Banana type is required for {crop_type}\")\n            if crop_info.get('growth_mode') == \"Select...\":\n                errors.append(f\"Growth mode is required for {crop_type}\")\n        elif crop_type == \"Other\":\n            if not crop_info.get('other_crop_name'):\n                errors.append(f\"Crop name is required for {crop_type}\")\n        \n        # Validate production fields for each crop\n        if crop_info.get('qty_harvested') is not None:\n            if crop_info['qty_harvested'] < 0:\n                errors.append(f\"Quantity harvested cannot be negative for {crop_type}\")\n            if crop_info['qty_harvested'] > 1000000:\n                errors.append(f\"Quantity harvested seems unrealistic for {crop_type} (max 1,000,000)\")\n        \n        if crop_info.get('price_per_unit') is not None:\n            if crop_info['price_per_unit'] < 0:\n                errors.append(f\"Price per unit cannot be negative for {crop_type}\")\n            if crop_info['price_per_unit'] > 10000:\n                errors.append(f\"Price per unit seems unrealistic for {crop_type} (max $10,000)\")\n        \n        if crop_info.get('area_acres') is not None and crop_info['area_acres'] > 0:\n            if crop_info['area_acres'] > 10000:\n                errors.append(f\"Area in acres seems unrealistic for {crop_type} (max 10,000 acres)\")\n        \n        # Check production fields have units if quantity is provided\n        if crop_info.get('qty_harvested') and crop_info.get('qty_harvested') > 0:\n            if crop_info.get('unit') == \"Select...\" or not crop_info.get('unit'):\n                errors.append(f\"Unit is required when quantity harvested is provided for {crop_type}\")\n    \n    # Return validation result\n    if errors:\n        return False, \"; \".join(errors)\n    else:\n        return True, \"Validation successful\"\n\ndef validate_field_boundary(data):\n    \"\"\"Validate field boundary data before saving\"\"\"\n    errors = []\n    \n    # Required fields\n    if not data.get('field_name') or len(data['field_name'].strip()) < 1:\n        errors.append(\"Field name is required\")\n    \n    if not data.get('field_type') or data['field_type'] == \"Select...\":\n        errors.append(\"Field type is required\")\n    \n    if not data.get('coordinates') or len(data['coordinates']) < 3:\n        errors.append(\"Field boundary must have at least 3 points\")\n    \n    # Field name validation\n    if data.get('field_name'):\n        if len(data['field_name']) > 100:\n            errors.append(\"Field name must be less than 100 characters\")\n        if not re.match(r'^[a-zA-Z0-9\\s\\-_\\.]+$', data['field_name']):\n            errors.append(\"Field name contains invalid characters\")\n    \n    # Area validation\n    if data.get('area_estimate'):\n        if data['area_estimate'] <= 0:\n            errors.append(\"Area estimate must be greater than 0\")\n        if data['area_estimate'] > 10000:\n            errors.append(\"Area estimate seems unrealistic (max 10,000 acres)\")\n    \n    # Notes length check\n    if data.get('notes') and len(data['notes']) > 500:\n        errors.append(\"Notes must be less than 500 characters\")\n    \n    # Return validation result\n    if errors:\n        return False, \"; \".join(errors)\n    else:\n        return True, \"Validation successful\"\n\ndef sanitize_input(text):\n    \"\"\"Sanitize text input to prevent basic security issues\"\"\"\n    if not text:\n        return \"\"\n    \n    # Remove potentially harmful characters\n    sanitized = str(text).strip()\n    \n    # Remove HTML tags\n    sanitized = re.sub(r'<[^>]+>', '', sanitized)\n    \n    # Remove SQL injection patterns (basic)\n    dangerous_patterns = [\n        r'(\\b(SELECT|INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|EXEC|EXECUTE)\\b)',\n        r'(--|#|\\/\\*|\\*\\/)',\n        r'(\\bOR\\b.*=.*\\bOR\\b)',\n        r'(\\bAND\\b.*=.*\\bAND\\b)'\n    ]\n    \n    for pattern in dangerous_patterns:\n        sanitized = re.sub(pattern, '', sanitized, flags=re.IGNORECASE)\n    \n    return sanitized\n\ndef validate_coordinates(coordinates):\n    \"\"\"Validate coordinate data for field boundaries\"\"\"\n    if not coordinates or not isinstance(coordinates, list):\n        return False, \"Invalid coordinates format\"\n    \n    if len(coordinates) < 3:\n        return False, \"Minimum 3 coordinate points required\"\n    \n    if len(coordinates) > 1000:\n        return False, \"Too many coordinate points (max 1000)\"\n    \n    for coord in coordinates:\n        if not isinstance(coord, list) or len(coord) != 2:\n            return False, \"Each coordinate must have latitude and longitude\"\n        \n        try:\n            lat, lng = float(coord[0]), float(coord[1])\n            if not (-90 <= lat <= 90) or not (-180 <= lng <= 180):\n                return False, \"Coordinates out of valid range\"\n        except (ValueError, TypeError):\n            return False, \"Coordinates must be valid numbers\"\n    \n    return True, \"Coordinates are valid\"\n","size_bytes":7187},"analyze_database.py":{"content":"import sqlite3\nimport json\nimport pandas as pd\n\ndef analyze_database():\n    \"\"\"Analyze the current database structure and data\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    cursor = conn.cursor()\n    \n    print(\"=== DATABASE SCHEMA ANALYSIS ===\\n\")\n    \n    # Get table schemas\n    cursor.execute(\"SELECT sql FROM sqlite_master WHERE type='table'\")\n    schemas = cursor.fetchall()\n    \n    for schema in schemas:\n        print(f\"Table Schema:\\n{schema[0]}\\n\")\n    \n    print(\"=== FORM_RESPONSES TABLE ANALYSIS ===\\n\")\n    \n    # Check form_responses table structure\n    cursor.execute(\"PRAGMA table_info(form_responses)\")\n    columns = cursor.fetchall()\n    print(\"Form_responses columns:\")\n    for col in columns:\n        print(f\"  - {col[1]} ({col[2]}) {'NOT NULL' if col[3] else ''} {'PRIMARY KEY' if col[5] else ''}\")\n    \n    # Get sample data from form_responses\n    cursor.execute(\"SELECT * FROM form_responses LIMIT 3\")\n    form_data = cursor.fetchall()\n    \n    print(f\"\\nTotal form_responses records: {len(form_data)}\")\n    if form_data:\n        print(\"\\nSample form_responses records:\")\n        for i, record in enumerate(form_data):\n            print(f\"\\nRecord {i+1}:\")\n            print(f\"  ID: {record[0]}\")\n            print(f\"  Farmer ID: {record[1]}\")\n            print(f\"  District: {record[2]}\")\n            print(f\"  Village: {record[3]}\")\n            print(f\"  EA Code: {record[4]}\")\n            print(f\"  Season/Year: {record[5]}\")\n            print(f\"  Crop Type: {record[6]}\")\n            print(f\"  Submission Date: {record[8]}\")\n            \n            # Parse and display JSON form data\n            try:\n                json_data = json.loads(record[7])\n                print(f\"  JSON Form Data Keys: {list(json_data.keys())}\")\n                if 'selected_crops' in json_data:\n                    print(f\"  Selected Crops: {json_data['selected_crops']}\")\n                if 'crop_data' in json_data:\n                    print(f\"  Crop Data Keys: {list(json_data['crop_data'].keys())}\")\n            except json.JSONDecodeError:\n                print(f\"  Form Data (raw): {record[7][:100]}...\")\n    \n    print(\"\\n=== FIELD_BOUNDARIES TABLE ANALYSIS ===\\n\")\n    \n    # Check field_boundaries table structure\n    cursor.execute(\"PRAGMA table_info(field_boundaries)\")\n    columns = cursor.fetchall()\n    print(\"Field_boundaries columns:\")\n    for col in columns:\n        print(f\"  - {col[1]} ({col[2]}) {'NOT NULL' if col[3] else ''} {'PRIMARY KEY' if col[5] else ''}\")\n    \n    # Get sample data from field_boundaries\n    cursor.execute(\"SELECT * FROM field_boundaries LIMIT 3\")\n    boundary_data = cursor.fetchall()\n    \n    print(f\"\\nTotal field_boundaries records: {len(boundary_data)}\")\n    if boundary_data:\n        print(\"\\nSample field_boundaries records:\")\n        for i, record in enumerate(boundary_data):\n            print(f\"\\nBoundary {i+1}:\")\n            print(f\"  ID: {record[0]}\")\n            print(f\"  Farmer ID: {record[1]}\")\n            print(f\"  Field Name: {record[2]}\")\n            print(f\"  Field Type: {record[3]}\")\n            print(f\"  Crop Type: {record[4]}\")\n            print(f\"  Area Estimate: {record[6]}\")\n            print(f\"  Creation Date: {record[8]}\")\n            print(f\"  Coordinates Length: {len(record[5]) if record[5] else 0}\")\n    \n    print(\"\\n=== RELATIONSHIP ANALYSIS ===\\n\")\n    \n    # Check potential relationships\n    cursor.execute(\"SELECT DISTINCT farmer_id FROM form_responses\")\n    form_farmers = {row[0] for row in cursor.fetchall()}\n    \n    cursor.execute(\"SELECT DISTINCT farmer_id FROM field_boundaries\")\n    boundary_farmers = {row[0] for row in cursor.fetchall()}\n    \n    print(f\"Farmers in form_responses: {len(form_farmers)}\")\n    print(f\"Farmers in field_boundaries: {len(boundary_farmers)}\")\n    print(f\"Common farmers: {len(form_farmers.intersection(boundary_farmers))}\")\n    \n    # Check crop type overlap\n    cursor.execute(\"SELECT DISTINCT crop_type FROM form_responses\")\n    form_crops = {row[0] for row in cursor.fetchall()}\n    \n    cursor.execute(\"SELECT DISTINCT crop_type FROM field_boundaries\")\n    boundary_crops = {row[0] for row in cursor.fetchall()}\n    \n    print(f\"\\nCrop types in form_responses: {form_crops}\")\n    print(f\"Crop types in field_boundaries: {boundary_crops}\")\n    print(f\"Common crop types: {form_crops.intersection(boundary_crops)}\")\n    \n    # Check for potential farmer_id + crop_type combinations\n    cursor.execute(\"\"\"\n        SELECT f.farmer_id, f.crop_type, COUNT(*) as form_count\n        FROM form_responses f\n        GROUP BY f.farmer_id, f.crop_type\n    \"\"\")\n    form_combinations = cursor.fetchall()\n    \n    cursor.execute(\"\"\"\n        SELECT b.farmer_id, b.crop_type, COUNT(*) as boundary_count\n        FROM field_boundaries b\n        GROUP BY b.farmer_id, b.crop_type\n    \"\"\")\n    boundary_combinations = cursor.fetchall()\n    \n    print(f\"\\nFarmer+Crop combinations in forms: {len(form_combinations)}\")\n    print(f\"Farmer+Crop combinations in boundaries: {len(boundary_combinations)}\")\n    \n    if form_combinations:\n        print(\"\\nSample form combinations:\")\n        for combo in form_combinations[:3]:\n            print(f\"  {combo[0]} + {combo[1]}: {combo[2]} records\")\n    \n    if boundary_combinations:\n        print(\"\\nSample boundary combinations:\")\n        for combo in boundary_combinations[:3]:\n            print(f\"  {combo[0]} + {combo[1]}: {combo[2]} records\")\n    \n    conn.close()\n\nif __name__ == \"__main__\":\n    analyze_database()","size_bytes":5493},"analyze_database_fixed.py":{"content":"import sqlite3\nimport json\n\ndef analyze_database():\n    \"\"\"Analyze the current database structure and data\"\"\"\n    conn = sqlite3.connect('agricultural_data.db')\n    cursor = conn.cursor()\n    \n    print(\"=== DATABASE SCHEMA ANALYSIS ===\\n\")\n    \n    # Get table schemas\n    cursor.execute(\"SELECT sql FROM sqlite_master WHERE type='table'\")\n    schemas = cursor.fetchall()\n    \n    for schema in schemas:\n        if schema[0] and 'sqlite_sequence' not in schema[0]:\n            print(f\"Table Schema:\\n{schema[0]}\\n\")\n    \n    print(\"=== FORM_RESPONSES TABLE ANALYSIS ===\\n\")\n    \n    # Check form_responses table structure\n    cursor.execute(\"PRAGMA table_info(form_responses)\")\n    form_columns = cursor.fetchall()\n    print(\"Form_responses columns:\")\n    for col in form_columns:\n        print(f\"  - Column {col[0]}: {col[1]} ({col[2]}) {'NOT NULL' if col[3] else ''} {'PRIMARY KEY' if col[5] else ''}\")\n    \n    # Get sample data from form_responses\n    cursor.execute(\"SELECT * FROM form_responses\")\n    form_data = cursor.fetchall()\n    \n    print(f\"\\nTotal form_responses records: {len(form_data)}\")\n    if form_data:\n        print(\"\\nSample form_responses records:\")\n        for i, record in enumerate(form_data):\n            print(f\"\\nRecord {i+1}:\")\n            print(f\"  ID: {record[0]}\")\n            print(f\"  Farmer ID: {record[1]}\")\n            print(f\"  District: {record[2]}\")\n            print(f\"  Village: {record[3]}\")\n            print(f\"  EA Code: {record[4]}\")\n            print(f\"  Season/Year: {record[5]}\")\n            print(f\"  Crop Type (field): {record[6]}\")\n            print(f\"  Submission Date: {record[8]}\")\n            \n            # Parse and display JSON form data\n            try:\n                json_data = json.loads(record[7])\n                print(f\"  JSON Form Data Keys: {list(json_data.keys())}\")\n                if 'selected_crops' in json_data:\n                    print(f\"  Selected Crops: {json_data['selected_crops']}\")\n                if 'crop_data' in json_data:\n                    print(f\"  Crop Data Keys: {list(json_data['crop_data'].keys())}\")\n                    # Show sample crop data structure\n                    for crop, data in json_data['crop_data'].items():\n                        print(f\"    {crop} data keys: {list(data.keys())[:5]}...\")  # Show first 5 keys\n            except json.JSONDecodeError:\n                print(f\"  Form Data (raw): {record[7][:100]}...\")\n    \n    print(\"\\n=== FIELD_BOUNDARIES TABLE ANALYSIS ===\\n\")\n    \n    # Check field_boundaries table structure\n    cursor.execute(\"PRAGMA table_info(field_boundaries)\")\n    boundary_columns = cursor.fetchall()\n    print(\"Field_boundaries columns:\")\n    for col in boundary_columns:\n        print(f\"  - Column {col[0]}: {col[1]} ({col[2]}) {'NOT NULL' if col[3] else ''} {'PRIMARY KEY' if col[5] else ''}\")\n    \n    # Get sample data from field_boundaries\n    cursor.execute(\"SELECT * FROM field_boundaries\")\n    boundary_data = cursor.fetchall()\n    \n    print(f\"\\nTotal field_boundaries records: {len(boundary_data)}\")\n    if boundary_data:\n        print(\"\\nSample field_boundaries records:\")\n        for i, record in enumerate(boundary_data):\n            print(f\"\\nBoundary {i+1}:\")\n            print(f\"  ID: {record[0]}\")\n            print(f\"  Farmer ID: {record[1]}\")\n            print(f\"  Field Name: {record[2]}\")\n            print(f\"  Field Type: {record[3]}\")\n            \n            # Handle columns based on actual structure\n            num_cols = len(record)\n            print(f\"  Total columns in record: {num_cols}\")\n            \n            if num_cols >= 5:\n                print(f\"  Column 4 (coordinates?): {str(record[4])[:100]}...\")\n            if num_cols >= 6:\n                print(f\"  Column 5 (area?): {record[5]}\")\n            if num_cols >= 7:\n                print(f\"  Column 6 (notes?): {record[6]}\")\n            if num_cols >= 8:\n                print(f\"  Column 7 (date?): {record[7]}\")\n            if num_cols >= 9:\n                print(f\"  Column 8 (crop_type?): {record[8]}\")\n    \n    print(\"\\n=== RELATIONSHIP ANALYSIS ===\\n\")\n    \n    # Check potential relationships - farmer_id analysis\n    cursor.execute(\"SELECT DISTINCT farmer_id FROM form_responses\")\n    form_farmers = {row[0] for row in cursor.fetchall()}\n    \n    cursor.execute(\"SELECT DISTINCT farmer_id FROM field_boundaries\")\n    boundary_farmers = {row[0] for row in cursor.fetchall()}\n    \n    print(f\"Farmers in form_responses: {len(form_farmers)}\")\n    print(f\"Form farmer IDs: {form_farmers}\")\n    print(f\"Farmers in field_boundaries: {len(boundary_farmers)}\")\n    print(f\"Boundary farmer IDs: {boundary_farmers}\")\n    print(f\"Common farmers: {form_farmers.intersection(boundary_farmers)}\")\n    \n    # Analyze form_responses crop storage pattern\n    print(f\"\\n=== CROP DATA STORAGE ANALYSIS ===\\n\")\n    \n    if form_data:\n        for i, record in enumerate(form_data):\n            try:\n                json_data = json.loads(record[7])\n                selected_crops = json_data.get('selected_crops', [])\n                crop_data = json_data.get('crop_data', {})\n                \n                print(f\"Form record {i+1}:\")\n                print(f\"  Farmer: {record[1]}\")\n                print(f\"  Crops selected: {selected_crops}\")\n                print(f\"  Crop data available for: {list(crop_data.keys())}\")\n                \n                # Show production data for each crop\n                for crop in crop_data:\n                    crop_info = crop_data[crop]\n                    qty = crop_info.get('qty_harvested', 'N/A')\n                    unit = crop_info.get('unit', 'N/A')\n                    print(f\"    {crop}: {qty} {unit}\")\n                \n                print()\n            except json.JSONDecodeError:\n                continue\n    \n    conn.close()\n    \n    print(\"\\n=== DATABASE DESIGN RECOMMENDATIONS ===\\n\")\n    print(\"Based on the analysis above, here are the key findings and recommendations:\")\n    print(\"1. Current structure allows one form_responses record to contain multiple crops\")\n    print(\"2. Field_boundaries table stores one boundary per record with one crop_type\")\n    print(\"3. Multiple boundaries can exist for the same farmer_id + crop_type combination\")\n    print(\"4. The farmer_id field provides the primary linking mechanism\")\n    print(\"5. JSON storage in form_responses provides flexibility but makes querying complex\")\n\nif __name__ == \"__main__\":\n    analyze_database()","size_bytes":6459},"database_analysis_report.md":{"content":"# Database Analysis Report: Linking Production Data with Plot Boundaries\n\n## Executive Summary\n\nThe current database structure uses two main tables with different approaches to crop data storage:\n- **form_responses**: Stores multiple crops per record using JSON structure\n- **field_boundaries**: Stores one crop per boundary record\n\nThe primary linking mechanism is `farmer_id`, with crop-specific linking possible through individual crop extraction from JSON data.\n\n## Current Database Structure Analysis\n\n### 1. form_responses Table Structure\n\n```sql\nCREATE TABLE form_responses (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    farmer_id TEXT NOT NULL,\n    district TEXT NOT NULL,\n    village TEXT NOT NULL,\n    ea_code TEXT,\n    season_year TEXT NOT NULL,\n    crop_type TEXT NOT NULL,          -- Comma-separated crop names\n    form_data TEXT NOT NULL,          -- JSON containing detailed crop data\n    submission_date TEXT NOT NULL\n)\n```\n\n**Key Characteristics:**\n- One record per farmer per form submission\n- Multiple crops stored in single record via JSON\n- `crop_type` field contains comma-separated crop names (e.g., \"Coconut, Cocoa\")\n- Detailed production data nested in JSON structure under `crop_data`\n\n**Sample Data Structure:**\n```json\n{\n  \"farmer_id\": \"EA10208-HH0012\",\n  \"selected_crops\": [\"Coconut\", \"Cocoa\"],\n  \"crop_data\": {\n    \"Coconut\": {\n      \"qty_harvested\": 10.0,\n      \"unit\": \"Pile\",\n      \"growth_mode\": \"Single crop\",\n      \"trees_harvested\": 5,\n      ...\n    },\n    \"Cocoa\": {\n      \"qty_harvested\": 10.0,\n      \"unit\": \"Kg\",\n      \"growth_mode\": \"Mixed crop\",\n      ...\n    }\n  }\n}\n```\n\n### 2. field_boundaries Table Structure\n\n```sql\nCREATE TABLE field_boundaries (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    farmer_id TEXT NOT NULL,\n    field_name TEXT NOT NULL,\n    field_type TEXT NOT NULL,\n    coordinates TEXT NOT NULL,        -- JSON array of boundary coordinates\n    area_estimate REAL,\n    notes TEXT,\n    creation_date TEXT NOT NULL,\n    crop_type TEXT DEFAULT \"Unknown\"  -- Single crop per boundary\n)\n```\n\n**Key Characteristics:**\n- One record per field boundary\n- Single crop_type per boundary record\n- Multiple boundaries can exist for same farmer + crop combination\n- Coordinates stored as JSON array of lat/lon pairs\n\n## Current Data Analysis\n\n**Existing Records:**\n- **form_responses**: 1 record (Farmer: EA10208-HH0012, Crops: Coconut, Cocoa)\n- **field_boundaries**: 3 records\n  - Field1: EA10208-HH0012, Coconut\n  - Field2: EA10208-HH0012, Cocoa  \n  - Field3: EA10208-HH0014, Other\n\n**Linking Potential:**\n- Common farmers: 1 (EA10208-HH0012)\n- This farmer has production data for 2 crops and boundaries for 2 matching crops\n- Perfect example of the intended relationship\n\n## Recommended Linking Strategy\n\n### Option 1: Current Schema with Enhanced Querying (RECOMMENDED)\n\n**Advantages:**\n- No schema changes required\n- Preserves existing data integrity\n- Flexible JSON storage allows for crop-specific attributes\n\n**Implementation Approach:**\n\n1. **Create Linking Views/Functions:**\n```python\ndef get_crop_production_data(farmer_id, crop_type):\n    \"\"\"Extract specific crop data from JSON structure\"\"\"\n    query = \"SELECT form_data FROM form_responses WHERE farmer_id = ?\"\n    # Parse JSON and extract crop_type specific data\n    return crop_specific_production_data\n\ndef get_field_boundaries_for_crop(farmer_id, crop_type):\n    \"\"\"Get all boundaries for a specific farmer+crop combination\"\"\"\n    query = \"\"\"SELECT * FROM field_boundaries \n               WHERE farmer_id = ? AND crop_type = ?\"\"\"\n    return boundary_records\n```\n\n2. **Linking Logic:**\n```python\ndef link_production_to_boundaries(farmer_id, crop_type):\n    \"\"\"Link production data with field boundaries\"\"\"\n    production_data = get_crop_production_data(farmer_id, crop_type)\n    boundaries = get_field_boundaries_for_crop(farmer_id, crop_type)\n    \n    return {\n        'production': production_data,\n        'boundaries': boundaries,\n        'total_fields': len(boundaries),\n        'total_area': sum([b['area_estimate'] for b in boundaries])\n    }\n```\n\n### Option 2: Normalized Schema (Alternative)\n\n**Create separate crop-specific production table:**\n```sql\nCREATE TABLE crop_production (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    farmer_id TEXT NOT NULL,\n    crop_type TEXT NOT NULL,\n    season_year TEXT NOT NULL,\n    qty_harvested REAL,\n    unit TEXT,\n    price_per_unit REAL,\n    production_data TEXT,  -- JSON for crop-specific attributes\n    form_response_id INTEGER,  -- Link to original form\n    FOREIGN KEY (form_response_id) REFERENCES form_responses(id)\n)\n```\n\n**Advantages:**\n- Better normalization\n- Easier querying and indexing\n- One-to-many relationships clearer\n\n**Disadvantages:**\n- Requires schema migration\n- Data duplication\n- More complex form submission logic\n\n## Implementation Recommendations\n\n### Phase 1: Enhanced Dashboard with Current Schema\n\n1. **Create Dashboard Helper Functions:**\n```python\ndef get_farmer_crop_summary(farmer_id):\n    \"\"\"Get complete crop summary for a farmer\"\"\"\n    # Extract production data from JSON\n    # Match with field boundaries\n    # Calculate totals and metrics\n    \ndef get_crop_analysis():\n    \"\"\"Analyze all crops across all farmers\"\"\"\n    # Aggregate production by crop type\n    # Link with boundary data\n    # Calculate productivity metrics\n```\n\n2. **Dashboard Features to Implement:**\n- Production vs. Area Analysis (yield per acre by crop)\n- Field Distribution by Crop Type\n- Farmer-specific Crop Portfolio View\n- Geographic Distribution of Crops\n\n3. **Query Optimization:**\n- Create indexes on farmer_id in both tables\n- Consider materialized views for complex crop aggregations\n\n### Phase 2: Schema Enhancement (Future)\n\nIf the application grows significantly, consider:\n1. Separate crop_production table for easier querying\n2. Crop-specific attribute tables for complex crop data\n3. Spatial indexes for boundary data\n\n## Linking Implementation Example\n\n```python\ndef create_integrated_dashboard_data():\n    \"\"\"Create integrated view of production and boundary data\"\"\"\n    \n    results = []\n    \n    # Get all form responses\n    conn = sqlite3.connect('agricultural_data.db')\n    cursor = conn.cursor()\n    \n    cursor.execute(\"SELECT * FROM form_responses\")\n    forms = cursor.fetchall()\n    \n    for form in forms:\n        farmer_id = form[1]\n        form_data = json.loads(form[7])\n        selected_crops = form_data.get('selected_crops', [])\n        crop_data = form_data.get('crop_data', {})\n        \n        for crop in selected_crops:\n            # Get production data for this crop\n            production = crop_data.get(crop, {})\n            \n            # Get field boundaries for this farmer+crop\n            cursor.execute(\"\"\"\n                SELECT * FROM field_boundaries \n                WHERE farmer_id = ? AND crop_type = ?\n            \"\"\", (farmer_id, crop))\n            \n            boundaries = cursor.fetchall()\n            \n            # Create integrated record\n            integrated_record = {\n                'farmer_id': farmer_id,\n                'crop_type': crop,\n                'production_data': production,\n                'field_boundaries': boundaries,\n                'total_fields': len(boundaries),\n                'total_area': sum([b[5] for b in boundaries if b[5]]),\n                'yield_per_acre': calculate_yield_per_acre(production, boundaries)\n            }\n            \n            results.append(integrated_record)\n    \n    conn.close()\n    return results\n```\n\n## Key Benefits of This Approach\n\n1. **Natural Linking:** farmer_id + crop_type provides logical relationship\n2. **Flexible Storage:** JSON in production table allows crop-specific attributes\n3. **Multiple Boundaries:** Supports multiple fields per crop per farmer\n4. **Scalable:** Can handle complex agricultural scenarios\n5. **Analytical Power:** Enables yield analysis, area efficiency, etc.\n\n## Next Steps\n\n1. Implement helper functions for data extraction and linking\n2. Create integrated dashboard views showing production + boundary data\n3. Add validation to ensure crop_type consistency between tables\n4. Consider adding indexes for performance optimization\n5. Test with additional sample data to validate approach\n\n## Conclusion\n\nThe current database structure is well-suited for linking production data with plot boundaries using the farmer_id + crop_type combination. The JSON storage in form_responses provides flexibility while the normalized field_boundaries table allows for multiple plots per crop. This approach supports the agricultural use case effectively without requiring schema changes.","size_bytes":8613},"pages/1_Register_Crops.py":{"content":"import streamlit as st\nimport sqlite3\nimport folium\nfrom streamlit_folium import st_folium\nimport json\nfrom datetime import datetime\nfrom utils.validators import validate_form_data\n\nst.set_page_config(page_title=\"Register Crops\", page_icon=\"🌾\")\n\n# Page namespace and state cleanup\nPAGE_PREFIX = \"register\"\nk = lambda name: f\"{PAGE_PREFIX}:{name}\"\n\ndef cleanup_foreign_keys(current_page):\n    \"\"\"Remove session state keys from other pages to prevent UI bleeding\"\"\"\n    keys_to_delete = []\n    for key in st.session_state.keys():\n        if isinstance(key, str) and \":\" in key:\n            if not key.startswith(f\"{current_page}:\"):\n                keys_to_delete.append(key)\n    \n    for key in keys_to_delete:\n        del st.session_state[key]\n\n# Clean up state from other pages\ncleanup_foreign_keys(PAGE_PREFIX)\n\nst.title(\"Register Crops 🌾\")\nst.markdown(\n    \"Complete agricultural registration for your crops. Select crops below to enter production data and draw field boundaries.\"\n)\n\n# Initialize session state for form data\nif k('form_submitted') not in st.session_state:\n    st.session_state[k('form_submitted')] = False\n\n\ndef save_form_data(data):\n    \"\"\"Save form data to database\"\"\"\n    try:\n        conn = sqlite3.connect('agricultural_data.db')\n        cursor = conn.cursor()\n\n        # Convert data to JSON string for flexible storage\n        crops_str = \", \".join(\n            data['selected_crops']) if data.get('selected_crops') else \"None\"\n        cursor.execute(\n            '''\n            INSERT INTO form_responses \n            (farmer_id, district, village, season_year, crop_type, form_data, submission_date)\n            VALUES (?, ?, ?, ?, ?, ?, ?)\n        ''',\n            (data['farmer_id'], data['district'],\n             data['village'], data['season_year'], crops_str, json.dumps(data),\n             datetime.now().isoformat()))\n\n        conn.commit()\n        conn.close()\n        return True\n    except Exception as e:\n        st.error(f\"Error saving production data: {str(e)}\")\n        return False\n\n\ndef save_field_boundary(field_data):\n    \"\"\"Save field boundary data to database\"\"\"\n    try:\n        conn = sqlite3.connect('agricultural_data.db')\n        cursor = conn.cursor()\n\n        cursor.execute(\n            '''\n            INSERT INTO field_boundaries \n            (farmer_id, field_name, field_type, crop_type, coordinates, area_estimate, notes, creation_date)\n            VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n        ''', (field_data['farmer_id'], field_data['field_name'],\n              field_data['field_type'], field_data['crop_type'],\n              json.dumps(\n                  field_data['coordinates']), field_data['area_estimate'],\n              field_data['notes'], datetime.now().isoformat()))\n\n        conn.commit()\n        conn.close()\n        return True\n    except Exception as e:\n        st.error(f\"Error saving field boundary: {str(e)}\")\n        return False\n\n\n# Define crop options and field structures\nCROP_OPTIONS = [\"Coconut\", \"Cocoa\", \"Breadfruit\", \"Banana\", \"Kava\", \"Other\"]\nUNITS = [\"Kg\", \"Tonnes\", \"Each\", \"Pile\", \"Basket\", \"Packet\", \"Bundle\"]\nGROWTH_MODES = [\"Single crop\", \"Mixed crop\", \"Both single & mixed\"]\nPLANTING_SOURCES = [\n    \"Own saved seed/seedlings\", \"Another household\", \"Market/shop\",\n    \"Govt/extension\", \"NGO/project\", \"Company/association\", \"Other (specify)\"\n]\nBANANA_TYPES = [\"Fa'i palagi\", \"Fa'i Samoa\", \"Other (specify)\"]\nFIELD_TYPES = [\"Cropland\", \"Pasture\", \"Orchard\", \"Fallow Land\", \"Other\"]\n\n# Identification Information (outside form for immediate response)\nst.subheader(\"Identification\")\n\ncol1, col2 = st.columns(2)\n\nwith col1:\n    farmer_id = st.text_input(\"1. Farmer ID *\",\n                              placeholder=\"EA10208-HH0012\",\n                              key=k(\"farmer_id\"))\n    district = st.selectbox(\"2. District *\", [\n        \"Select...\", \"Vaimauga 1\", \"Vaimauga 2\", \"Vaimauga 3\", \"Vaimauga 4\",\n        \"Faleata 1\", \"Faleata 2\", \"Faleata 3\", \"Faleata 4\", \"Sagaga 1\",\n        \"Sagaga 2\", \"Sagaga 3\", \"Sagaga 4\", \"A'ana Alofi 1\", \"A'ana Alofi 2\",\n        \"A'ana Alofi 3\", \"A'ana Alofi 4\"\n    ],\n                            key=k(\"district\"))\n\nwith col2:\n    village = st.text_input(\"3. Village *\",\n                            placeholder=\"e.g., Moataa, Vaipuna...\",\n                            key=k(\"village\"))\n    season_year = st.text_input(\"4. Season/Year *\",\n                                placeholder=\"2024/25\",\n                                key=k(\"season_year\"))\n\nst.subheader(\"Crop Selection\")\nst.write(\"**(Check all that apply)**\")\n\n# Create checkboxes for each crop (outside form for immediate response)\nselected_crops = []\ncol1, col2, col3 = st.columns(3)\n\nwith col1:\n    if st.checkbox(\"Coconut\", key=k(\"crop_coconut\")):\n        selected_crops.append(\"Coconut\")\n    if st.checkbox(\"Cocoa\", key=k(\"crop_cocoa\")):\n        selected_crops.append(\"Cocoa\")\nwith col2:\n    if st.checkbox(\"Breadfruit\", key=k(\"crop_breadfruit\")):\n        selected_crops.append(\"Breadfruit\")\n    if st.checkbox(\"Banana\", key=k(\"crop_banana\")):\n        selected_crops.append(\"Banana\")\nwith col3:\n    if st.checkbox(\"Kava\", key=k(\"crop_kava\")):\n        selected_crops.append(\"Kava\")\n    if st.checkbox(\"Other\", key=k(\"crop_other\")):\n        selected_crops.append(\"Other\")\n\n# Store all crop data and boundary data\nall_crop_data = {}\nall_boundary_data = {}\n\n# Dynamic crop-specific fields for each selected crop (immediate display)\nif selected_crops:\n    for crop_type in selected_crops:\n        st.subheader(f\"{crop_type} Production and Field Registration\")\n\n        # Initialize crop data for this specific crop\n        crop_data = {}\n\n        if crop_type == \"Coconut\":\n            col1, col2 = st.columns(2)\n            with col1:\n                crop_data['growth_mode'] = st.selectbox(\n                    f\"How is Coconut grown? *\", [\"Select...\"] + GROWTH_MODES,\n                    key=k(\"coconut_growth_mode\"))\n                crop_data['pest_rhino_beetle'] = st.radio(\n                    \"Affected by rhinoceros beetle (last 12 months)?\",\n                    [\"Yes\", \"No\"],\n                    key=k(\"coconut_beetle\"))\n                crop_data['planted_last_12m'] = st.radio(\n                    \"Planted coconut (last 12 months)?\", [\"Yes\", \"No\"],\n                    key=k(\"coconut_planted\"))\n                crop_data['trees_harvested'] = st.number_input(\n                    \"Trees harvested (last 12 months)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"coconut_trees_harvested\"))\n            with col2:\n                crop_data['planting_sources'] = st.multiselect(\n                    \"Source(s) of planting material\",\n                    PLANTING_SOURCES,\n                    key=k(\"coconut_sources\"))\n                st.write(\"**Trees by age group:**\")\n                crop_data['age_0_5'] = st.number_input(\"0–5 years (count)\",\n                                                       min_value=0,\n                                                       step=1,\n                                                       key=k(\"coconut_age_0_5\"))\n                crop_data['age_6_10'] = st.number_input(\n                    \"6–10 years (count)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"coconut_age_6_10\"))\n                crop_data['age_11_20'] = st.number_input(\n                    \"11–20 years (count)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"coconut_age_11_20\"))\n                crop_data['age_21_30'] = st.number_input(\n                    \"21–30 years (count)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"coconut_age_21_30\"))\n                crop_data['age_31_plus'] = st.number_input(\n                    \"31+ years (count)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"coconut_age_31_plus\"))\n\n        elif crop_type == \"Cocoa\":\n            col1, col2 = st.columns(2)\n            with col1:\n                crop_data['growth_mode'] = st.selectbox(\n                    \"How is Cocoa grown? *\", [\"Select...\"] + GROWTH_MODES,\n                    key=k(\"cocoa_growth_mode\"))\n                crop_data['disease_mosaic'] = st.radio(\n                    \"Cocoa mosaic disease (last 12 months)?\", [\"Yes\", \"No\"],\n                    key=k(\"cocoa_disease\"))\n                crop_data['planted_last_12m'] = st.radio(\n                    \"Planted cocoa (last 12 months)?\", [\"Yes\", \"No\"],\n                    key=k(\"cocoa_planted\"))\n            with col2:\n                crop_data['planting_sources'] = st.multiselect(\n                    \"Source(s) of planting material\",\n                    PLANTING_SOURCES,\n                    key=k(\"cocoa_sources\"))\n                st.write(\"**Trees by age group:**\")\n                crop_data['age_0_2'] = st.number_input(\"0–2 years (count)\",\n                                                       min_value=0,\n                                                       step=1,\n                                                       key=k(\"cocoa_age_0_2\"))\n                crop_data['age_3_5'] = st.number_input(\"3–5 years (count)\",\n                                                       min_value=0,\n                                                       step=1,\n                                                       key=k(\"cocoa_age_3_5\"))\n                crop_data['age_6_10'] = st.number_input(\"6–10 years (count)\",\n                                                        min_value=0,\n                                                        step=1,\n                                                        key=k(\"cocoa_age_6_10\"))\n                crop_data['age_11_20'] = st.number_input(\n                    \"11–20 years (count)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"cocoa_age_11_20\"))\n                crop_data['age_21_30'] = st.number_input(\n                    \"21–30 years (count)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"cocoa_age_21_30\"))\n                crop_data['age_31_plus'] = st.number_input(\n                    \"31+ years (count)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"cocoa_age_31_plus\"))\n\n        elif crop_type == \"Breadfruit\":\n            col1, col2 = st.columns(2)\n            with col1:\n                crop_data['growth_mode'] = st.selectbox(\n                    \"How is Breadfruit grown? *\", [\"Select...\"] + GROWTH_MODES,\n                    key=k(\"breadfruit_growth_mode\"))\n                crop_data['trees_single_crop'] = st.number_input(\n                    \"Breadfruit trees (single crop)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"breadfruit_trees_single\"))\n                crop_data['planted_last_12m'] = st.radio(\n                    \"Planted breadfruit (last 12 months)?\", [\"Yes\", \"No\"],\n                    key=k(\"breadfruit_planted\"))\n            with col2:\n                crop_data['trees_harvested'] = st.number_input(\n                    \"Trees harvested (last 12 months)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"breadfruit_trees_harvested\"))\n                crop_data['planting_sources'] = st.multiselect(\n                    \"Source(s) of planting material\",\n                    PLANTING_SOURCES,\n                    key=k(\"breadfruit_sources\"))\n                crop_data['area_acres'] = st.number_input(\n                    \"Area planted (acres)\",\n                    min_value=0.0,\n                    step=0.01,\n                    key=k(\"breadfruit_area\"))\n\n        elif crop_type == \"Banana\":\n            col1, col2 = st.columns(2)\n            with col1:\n                crop_data['banana_type'] = st.selectbox(\n                    \"Banana type *\", [\"Select...\"] + BANANA_TYPES,\n                    key=k(\"banana_type\"))\n                crop_data['growth_mode'] = st.selectbox(\n                    \"How is Banana grown? *\", [\"Select...\"] + GROWTH_MODES,\n                    key=k(\"banana_growth_mode\"))\n                crop_data['plants_single_crop'] = st.number_input(\n                    \"Banana plants/suckers (single crop)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"banana_plants\"))\n            with col2:\n                crop_data['area_acres'] = st.number_input(\n                    \"Area planted (acres)\",\n                    min_value=0.0,\n                    step=0.01,\n                    key=k(\"banana_area\"))\n\n        elif crop_type == \"Kava\":\n            col1, col2 = st.columns(2)\n            with col1:\n                crop_data['planted_last_12m'] = st.radio(\n                    \"Planted kava (last 12 months)?\", [\"Yes\", \"No\"],\n                    key=k(\"kava_planted\"))\n                crop_data['plants_harvested'] = st.number_input(\n                    \"Plants harvested (last 12 months)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"kava_plants_harvested\"))\n            with col2:\n                crop_data['planting_sources'] = st.multiselect(\n                    \"Source(s) of planting material\",\n                    PLANTING_SOURCES,\n                    key=k(\"kava_sources\"))\n\n        elif crop_type == \"Other\":\n            col1, col2 = st.columns(2)\n            with col1:\n                crop_data['other_crop_name'] = st.text_input(\n                    \"Crop name *\",\n                    placeholder=\"e.g., Mango, Citrus...\",\n                    key=k(\"other_crop_name\"))\n                crop_data['plants_growing'] = st.number_input(\n                    \"Plants growing (count)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"other_plants_growing\"))\n            with col2:\n                crop_data['plants_harvested'] = st.number_input(\n                    \"Plants harvested (last 12 months)\",\n                    min_value=0,\n                    step=1,\n                    key=k(\"other_plants_harvested\"))\n\n        # Production fields for each crop\n        st.write(\"**Production Information:**\")\n        col1, col2 = st.columns(2)\n        with col1:\n            crop_data['qty_harvested'] = st.number_input(\n                \"Quantity harvested (last 12 months) *\",\n                min_value=0.0,\n                step=0.1,\n                key=k(f\"{crop_type.lower().replace(' ', '_')}_qty\"))\n            crop_data['unit'] = st.selectbox(\n                \"Unit of measure *\", [\"Select...\"] + UNITS,\n                key=k(f\"{crop_type.lower().replace(' ', '_')}_unit\"))\n        with col2:\n            crop_data['price_per_unit'] = st.number_input(\n                \"Average price per unit (last 12 months)\",\n                min_value=0.0,\n                step=0.01,\n                key=k(f\"{crop_type.lower().replace(' ', '_')}_price\"))\n\n        # Store this crop's data\n        all_crop_data[crop_type] = crop_data\n\n        # Field boundary mapping section\n        st.write(f\"**Draw the boundaries of your {crop_type} fields**\")\n        st.info(\n            \"**Instructions:** Use the drawing tools on the map to draw a shape around each of your field boundaries for the given crop type. Click on the ⬟ icon in the toolbar to start drawing.\"\n        )\n\n        # Initialize the map for this crop\n        map_key = f\"map_center_{crop_type.lower()}\"\n        if map_key not in st.session_state:\n            # Default to Upolu Island, Samoa - agricultural AOI\n            st.session_state[map_key] = [-13.9167, -171.7500]\n            st.session_state[f\"map_zoom_{crop_type.lower()}\"] = 12\n\n        # Create the base map with satellite imagery\n        m = folium.Map(\n            location=st.session_state[map_key],\n            zoom_start=st.session_state[f\"map_zoom_{crop_type.lower()}\"],\n            tiles=None)\n\n        # Add satellite tile layer\n        folium.TileLayer(\n            tiles=\n            'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n            attr='Esri',\n            name='Satellite',\n            overlay=False,\n            control=True).add_to(m)\n\n        # Add OpenStreetMap layer as backup\n        folium.TileLayer(tiles='OpenStreetMap',\n                         name='Street Map',\n                         overlay=False,\n                         control=True).add_to(m)\n\n        # Add drawing tools\n        from folium import plugins\n        draw = plugins.Draw(\n            export=True,\n            draw_options={\n                'polyline': False,\n                'polygon': True,\n                'circle': False,\n                'rectangle': False,\n                'marker': False,\n                'circlemarker': False,\n            },\n            edit_options={'poly': {\n                'allowIntersection': False\n            }})\n        draw.add_to(m)\n\n        # Add layer control\n        folium.LayerControl().add_to(m)\n\n        # Display the map\n        map_data = st_folium(m,\n                             width=None,\n                             height=400,\n                             returned_objects=[\"all_drawings\"],\n                             key=k(f\"map_{crop_type.lower()}\"))\n\n        # Process drawn polygons\n        boundary_data = []\n        total_area_hectares = 0\n        num_fields = 0\n\n        if map_data['all_drawings'] and len(map_data['all_drawings']) > 0:\n            # Process all polygons for this crop\n            polygons = [\n                drawing for drawing in map_data['all_drawings']\n                if drawing['geometry']['type'] == 'Polygon'\n            ]\n            num_fields = len(polygons)\n\n            if num_fields > 0:\n\n                # Calculate area for each polygon\n                def calculate_polygon_area_hectares(coords):\n                    \"\"\"Calculate polygon area in hectares using shoelace formula with lat/lng conversion\"\"\"\n                    n = len(coords)\n                    if n < 3:\n                        return 0\n\n                    # Shoelace formula for area in square degrees\n                    area_sq_degrees = 0\n                    for i in range(n):\n                        j = (i + 1) % n\n                        area_sq_degrees += coords[i][0] * coords[j][1]\n                        area_sq_degrees -= coords[j][0] * coords[i][1]\n                    area_sq_degrees = abs(area_sq_degrees) / 2\n\n                    # Convert to hectares (approximate for Samoa latitude ~-13.9°)\n                    # 1 degree lat ≈ 111 km, 1 degree lng ≈ 111 km * cos(lat)\n                    lat_avg = sum(coord[1] for coord in coords) / len(coords)\n                    import math\n                    meters_per_degree_lat = 111000  # meters per degree latitude\n                    meters_per_degree_lng = 111000 * math.cos(\n                        math.radians(lat_avg))  # meters per degree longitude\n\n                    # Convert square degrees to square meters\n                    area_sq_meters = area_sq_degrees * meters_per_degree_lat * meters_per_degree_lng\n\n                    # Convert to hectares (1 hectare = 10,000 m²)\n                    area_hectares = area_sq_meters / 10000\n                    return area_hectares\n\n                # Process each polygon\n                for i, polygon in enumerate(polygons):\n                    coordinates = polygon['geometry']['coordinates'][0]\n                    area_ha = calculate_polygon_area_hectares(coordinates)\n                    total_area_hectares += area_ha\n\n                    # Store boundary data for this polygon\n                    boundary_data.append({\n                        'field_name': f\"{crop_type} Field {i+1}\",\n                        'field_type': \"Cropland\",\n                        'coordinates': coordinates,\n                        'area_estimate': area_ha,\n                        'notes': \"\"\n                    })\n\n                # Display summary metrics\n                col1, col2 = st.columns(2)\n                with col1:\n                    st.metric(f\"Number of {crop_type} fields\", num_fields)\n                with col2:\n                    st.metric(\"Total area (ha)\", f\"{total_area_hectares:.2f}\")\n\n                # Store all boundary data for this crop\n                all_boundary_data[crop_type] = boundary_data\n        else:\n            st.info(\n                \"Draw a polygon on the map to define field boundaries for this crop.\"\n            )\n\n        st.divider()  # Visual separator between crops\n\n# Submit button (only show if crops are selected)\nif selected_crops:\n    if st.button(\"Submit Production Data & Field Boundaries\", type=\"primary\"):\n        submitted = True\n    else:\n        submitted = False\nelse:\n    submitted = False\n\nif submitted:\n    # Collect form data\n    form_data = {\n        'farmer_id': farmer_id,\n        'district': district,\n        'village': village,\n        'season_year': season_year,\n        'selected_crops': selected_crops,\n        'crop_data': all_crop_data  # Include all crop-specific data\n    }\n\n    # Validate form data\n    is_valid, error_message = validate_form_data(form_data)\n\n    if is_valid:\n        # Save production data\n        production_saved = save_form_data(form_data)\n\n        # Save boundary data for each crop that has it\n        boundaries_saved = []\n        total_boundaries_saved = 0\n        for crop_type, boundary_list in all_boundary_data.items():\n            if boundary_list:  # Check if list is not empty\n                crop_fields_saved = 0\n                for boundary_info in boundary_list:\n                    field_data = {\n                        'farmer_id': farmer_id,\n                        'field_name': boundary_info['field_name'],\n                        'field_type': boundary_info['field_type'],\n                        'crop_type': crop_type,\n                        'coordinates': boundary_info['coordinates'],\n                        'area_estimate': boundary_info['area_estimate'],\n                        'notes': boundary_info['notes']\n                    }\n                    if save_field_boundary(field_data):\n                        crop_fields_saved += 1\n                        total_boundaries_saved += 1\n                if crop_fields_saved > 0:\n                    boundaries_saved.append(crop_type)\n\n        if production_saved:\n            st.success(\"✅ Data submitted successfully!\")\n\n            # Show balloons animation\n            st.balloons()\n            st.session_state[k('form_submitted')] = True\n        else:\n            st.error(\"❌ Failed to submit production data. Please try again.\")\n    else:\n        st.error(f\"❌ {error_message}\")\n\n# Post-submission options\nif st.session_state[k('form_submitted')]:\n    col1, col2 = st.columns(2)\n    with col1:\n        if st.button(\"Retract & Edit\", type=\"secondary\"):\n            st.session_state[k('form_submitted')] = False\n            st.rerun()\n    with col2:\n        if st.button(\"Submit Another Entry\"):\n            # Clear all namespaced form data for fresh entry\n            keys_to_delete = []\n            for key in st.session_state.keys():\n                if isinstance(key, str) and key.startswith(f\"{PAGE_PREFIX}:\"):\n                    keys_to_delete.append(key)\n            \n            for key in keys_to_delete:\n                del st.session_state[key]\n\n            st.session_state[k('form_submitted')] = False\n            st.rerun()\n\nst.markdown(\"---\")\n","size_bytes":23543},"production_boundary_linking_demo.py":{"content":"import sqlite3\nimport json\nimport pandas as pd\nfrom typing import Dict, List, Any, Optional\n\nclass ProductionBoundaryLinker:\n    \"\"\"\n    Class to demonstrate linking production data with plot boundaries\n    using the existing database schema.\n    \"\"\"\n    \n    def __init__(self, db_path: str = 'agricultural_data.db'):\n        self.db_path = db_path\n    \n    def get_crop_production_data(self, farmer_id: str, crop_type: str) -> Optional[Dict]:\n        \"\"\"Extract specific crop production data from JSON structure\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        try:\n            cursor.execute(\"\"\"\n                SELECT form_data, season_year, submission_date \n                FROM form_responses \n                WHERE farmer_id = ?\n            \"\"\", (farmer_id,))\n            \n            result = cursor.fetchone()\n            if not result:\n                return None\n            \n            form_data = json.loads(result[0])\n            crop_data = form_data.get('crop_data', {})\n            \n            if crop_type not in crop_data:\n                return None\n            \n            production_data = crop_data[crop_type].copy()\n            production_data.update({\n                'season_year': result[1],\n                'submission_date': result[2],\n                'farmer_id': farmer_id,\n                'crop_type': crop_type\n            })\n            \n            return production_data\n            \n        except (json.JSONDecodeError, Exception) as e:\n            print(f\"Error extracting crop data: {e}\")\n            return None\n        finally:\n            conn.close()\n    \n    def get_field_boundaries_for_crop(self, farmer_id: str, crop_type: str) -> List[Dict]:\n        \"\"\"Get all field boundaries for a specific farmer+crop combination\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        try:\n            cursor.execute(\"\"\"\n                SELECT id, field_name, field_type, coordinates, \n                       area_estimate, notes, creation_date, crop_type\n                FROM field_boundaries \n                WHERE farmer_id = ? AND crop_type = ?\n                ORDER BY creation_date\n            \"\"\", (farmer_id, crop_type))\n            \n            boundaries = []\n            for row in cursor.fetchall():\n                boundary = {\n                    'id': row[0],\n                    'field_name': row[1],\n                    'field_type': row[2],\n                    'coordinates': json.loads(row[3]) if row[3] else [],\n                    'area_estimate': row[4],\n                    'notes': row[5],\n                    'creation_date': row[6],\n                    'crop_type': row[7]\n                }\n                boundaries.append(boundary)\n            \n            return boundaries\n            \n        except Exception as e:\n            print(f\"Error retrieving boundaries: {e}\")\n            return []\n        finally:\n            conn.close()\n    \n    def link_production_to_boundaries(self, farmer_id: str, crop_type: str) -> Dict[str, Any]:\n        \"\"\"\n        Link production data with field boundaries for a specific farmer+crop combination\n        \"\"\"\n        production_data = self.get_crop_production_data(farmer_id, crop_type)\n        boundaries = self.get_field_boundaries_for_crop(farmer_id, crop_type)\n        \n        if not production_data:\n            return {\n                'status': 'no_production_data',\n                'farmer_id': farmer_id,\n                'crop_type': crop_type,\n                'boundaries': boundaries\n            }\n        \n        # Calculate aggregated metrics\n        total_area = sum([b['area_estimate'] for b in boundaries if b['area_estimate']])\n        total_fields = len(boundaries)\n        \n        # Calculate yield per acre if possible\n        yield_per_acre = None\n        if total_area > 0 and production_data.get('qty_harvested'):\n            yield_per_acre = production_data['qty_harvested'] / total_area\n        \n        return {\n            'status': 'linked',\n            'farmer_id': farmer_id,\n            'crop_type': crop_type,\n            'production_data': production_data,\n            'field_boundaries': boundaries,\n            'summary_metrics': {\n                'total_fields': total_fields,\n                'total_area_acres': total_area,\n                'quantity_harvested': production_data.get('qty_harvested', 0),\n                'harvest_unit': production_data.get('unit', 'N/A'),\n                'yield_per_acre': yield_per_acre,\n                'price_per_unit': production_data.get('price_per_unit', 0),\n                'total_value': (production_data.get('qty_harvested', 0) * \n                              production_data.get('price_per_unit', 0))\n            }\n        }\n    \n    def get_all_farmer_crop_links(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all possible farmer+crop combinations and their linking status\"\"\"\n        conn = sqlite3.connect(self.db_path)\n        cursor = conn.cursor()\n        \n        # Get all farmer+crop combinations from production data\n        cursor.execute(\"SELECT farmer_id, form_data FROM form_responses\")\n        production_combinations = set()\n        \n        for row in cursor.fetchall():\n            farmer_id = row[0]\n            try:\n                form_data = json.loads(row[1])\n                selected_crops = form_data.get('selected_crops', [])\n                for crop in selected_crops:\n                    production_combinations.add((farmer_id, crop))\n            except json.JSONDecodeError:\n                continue\n        \n        # Get all farmer+crop combinations from boundary data\n        cursor.execute(\"SELECT DISTINCT farmer_id, crop_type FROM field_boundaries\")\n        boundary_combinations = set(cursor.fetchall())\n        \n        conn.close()\n        \n        # Create comprehensive linking analysis\n        all_combinations = production_combinations.union(boundary_combinations)\n        results = []\n        \n        for farmer_id, crop_type in all_combinations:\n            has_production = (farmer_id, crop_type) in production_combinations\n            has_boundaries = (farmer_id, crop_type) in boundary_combinations\n            \n            if has_production and has_boundaries:\n                # Full linking possible\n                link_result = self.link_production_to_boundaries(farmer_id, crop_type)\n                results.append(link_result)\n            elif has_production:\n                # Production only\n                production_data = self.get_crop_production_data(farmer_id, crop_type)\n                results.append({\n                    'status': 'production_only',\n                    'farmer_id': farmer_id,\n                    'crop_type': crop_type,\n                    'production_data': production_data,\n                    'field_boundaries': []\n                })\n            else:\n                # Boundaries only\n                boundaries = self.get_field_boundaries_for_crop(farmer_id, crop_type)\n                results.append({\n                    'status': 'boundaries_only',\n                    'farmer_id': farmer_id,\n                    'crop_type': crop_type,\n                    'production_data': None,\n                    'field_boundaries': boundaries\n                })\n        \n        return results\n    \n    def generate_dashboard_data(self) -> Dict[str, Any]:\n        \"\"\"Generate comprehensive dashboard data showing all linkages\"\"\"\n        all_links = self.get_all_farmer_crop_links()\n        \n        # Categorize results\n        fully_linked = [r for r in all_links if r['status'] == 'linked']\n        production_only = [r for r in all_links if r['status'] == 'production_only']\n        boundaries_only = [r for r in all_links if r['status'] == 'boundaries_only']\n        \n        # Calculate summary statistics\n        total_production_records = len([r for r in all_links if r.get('production_data')])\n        total_boundary_records = sum([len(r['field_boundaries']) for r in all_links])\n        \n        # Crop-wise analysis\n        crop_analysis = {}\n        for result in fully_linked:\n            crop = result['crop_type']\n            if crop not in crop_analysis:\n                crop_analysis[crop] = {\n                    'farmers': set(),\n                    'total_area': 0,\n                    'total_production': 0,\n                    'total_value': 0,\n                    'fields': 0\n                }\n            \n            metrics = result['summary_metrics']\n            crop_analysis[crop]['farmers'].add(result['farmer_id'])\n            crop_analysis[crop]['total_area'] += metrics.get('total_area_acres', 0)\n            crop_analysis[crop]['total_production'] += metrics.get('quantity_harvested', 0)\n            crop_analysis[crop]['total_value'] += metrics.get('total_value', 0)\n            crop_analysis[crop]['fields'] += metrics.get('total_fields', 0)\n        \n        # Convert sets to counts\n        for crop in crop_analysis:\n            crop_analysis[crop]['farmers'] = len(crop_analysis[crop]['farmers'])\n        \n        return {\n            'summary': {\n                'total_combinations': len(all_links),\n                'fully_linked': len(fully_linked),\n                'production_only': len(production_only),\n                'boundaries_only': len(boundaries_only),\n                'total_production_records': total_production_records,\n                'total_boundary_records': total_boundary_records,\n                'linking_success_rate': len(fully_linked) / len(all_links) if all_links else 0\n            },\n            'fully_linked_data': fully_linked,\n            'production_only_data': production_only,\n            'boundaries_only_data': boundaries_only,\n            'crop_analysis': crop_analysis\n        }\n\ndef demonstrate_linking():\n    \"\"\"Demonstrate the linking functionality with current data\"\"\"\n    linker = ProductionBoundaryLinker()\n    \n    print(\"=== PRODUCTION-BOUNDARY LINKING DEMONSTRATION ===\\n\")\n    \n    # Generate dashboard data\n    dashboard_data = linker.generate_dashboard_data()\n    \n    print(\"SUMMARY STATISTICS:\")\n    summary = dashboard_data['summary']\n    for key, value in summary.items():\n        if key == 'linking_success_rate':\n            print(f\"  {key}: {value:.1%}\")\n        else:\n            print(f\"  {key}: {value}\")\n    \n    print(f\"\\nFULLY LINKED FARMER+CROP COMBINATIONS ({len(dashboard_data['fully_linked_data'])}):\")\n    for result in dashboard_data['fully_linked_data']:\n        metrics = result['summary_metrics']\n        print(f\"\\n  {result['farmer_id']} - {result['crop_type']}:\")\n        print(f\"    Fields: {metrics['total_fields']}\")\n        print(f\"    Total Area: {metrics['total_area_acres']} acres\")\n        print(f\"    Production: {metrics['quantity_harvested']} {metrics['harvest_unit']}\")\n        if metrics['yield_per_acre']:\n            print(f\"    Yield per Acre: {metrics['yield_per_acre']:.2f} {metrics['harvest_unit']}/acre\")\n        print(f\"    Total Value: ${metrics['total_value']:.2f}\")\n    \n    print(f\"\\nPRODUCTION-ONLY DATA ({len(dashboard_data['production_only_data'])}):\")\n    for result in dashboard_data['production_only_data']:\n        if result['production_data']:\n            prod = result['production_data']\n            qty = prod.get('qty_harvested', 'N/A')\n            unit = prod.get('unit', 'N/A')\n            print(f\"  {result['farmer_id']} - {result['crop_type']}: {qty} {unit} (NO BOUNDARIES)\")\n    \n    print(f\"\\nBOUNDARY-ONLY DATA ({len(dashboard_data['boundaries_only_data'])}):\")\n    for result in dashboard_data['boundaries_only_data']:\n        boundary_count = len(result['field_boundaries'])\n        total_area = sum([b['area_estimate'] for b in result['field_boundaries'] if b['area_estimate']])\n        print(f\"  {result['farmer_id']} - {result['crop_type']}: {boundary_count} fields, {total_area} acres (NO PRODUCTION)\")\n    \n    print(f\"\\nCROP ANALYSIS:\")\n    for crop, analysis in dashboard_data['crop_analysis'].items():\n        print(f\"\\n  {crop}:\")\n        print(f\"    Farmers: {analysis['farmers']}\")\n        print(f\"    Total Fields: {analysis['fields']}\")\n        print(f\"    Total Area: {analysis['total_area']:.1f} acres\")\n        print(f\"    Total Production: {analysis['total_production']:.1f}\")\n        print(f\"    Total Value: ${analysis['total_value']:.2f}\")\n        if analysis['total_area'] > 0:\n            avg_yield = analysis['total_production'] / analysis['total_area']\n            print(f\"    Average Yield per Acre: {avg_yield:.2f}\")\n\nif __name__ == \"__main__\":\n    demonstrate_linking()","size_bytes":12618},"pages/3_View_Data.py":{"content":"import streamlit as st\n\n# Page configuration and widget key namespacing\nPAGE_PREFIX = \"view_data\"\n\n# Helper function for namespaced widget keys\ndef k(key_name):\n    \"\"\"Create a namespaced key for widgets to prevent state bleeding between pages.\"\"\"\n    return f\"{PAGE_PREFIX}:{key_name}\"\n\n# Add cleanup function for any foreign state\ndef cleanup_foreign_keys():\n    \"\"\"Remove session state keys from other pages to prevent bleeding.\"\"\"\n    keys_to_remove = []\n    for key in st.session_state.keys():\n        if isinstance(key, str) and \":\" in key and not key.startswith(f\"{PAGE_PREFIX}:\"):\n            keys_to_remove.append(key)\n    \n    for key in keys_to_remove:\n        del st.session_state[key]\n\n# Cleanup any foreign state on page load\ncleanup_foreign_keys()\nimport sqlite3\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime\nimport json\nimport folium\nfrom streamlit_folium import st_folium\n\nst.set_page_config(page_title=\"View Data\", layout=\"wide\")\n\nst.title(\"Agricultural Data Dashboard 📊\")\nst.markdown(\"Comprehensive view of collected agricultural data and insights\")\n\n\ndef load_form_data():\n    \"\"\"Load form response data from database\"\"\"\n    try:\n        conn = sqlite3.connect('agricultural_data.db')\n        df = pd.read_sql_query(\n            \"\"\"\n            SELECT * FROM form_responses \n            ORDER BY submission_date DESC\n        \"\"\", conn)\n        conn.close()\n\n        # Parse JSON form_data if it exists\n        if not df.empty and 'form_data' in df.columns:\n            # Expand JSON data into columns\n            expanded_data = []\n            for _, row in df.iterrows():\n                try:\n                    form_json = json.loads(row['form_data'])\n                    # Combine basic fields with JSON data\n                    combined_row = {\n                        'id': row['id'],\n                        'farmer_id': row['farmer_id'],\n                        'district': row['district'],\n                        'village': row['village'],\n                        'ea_code': row['ea_code'],\n                        'season_year': row['season_year'],\n                        'crop_type': row['crop_type'],\n                        'submission_date': row['submission_date'],\n                        **form_json  # Expand all JSON fields\n                    }\n                    expanded_data.append(combined_row)\n                except json.JSONDecodeError:\n                    # If JSON parsing fails, use basic row data\n                    expanded_data.append(row.to_dict())\n\n            df = pd.DataFrame(expanded_data)\n\n        return df\n    except Exception as e:\n        st.error(f\"Error loading form data: {str(e)}\")\n        return pd.DataFrame()\n\n\ndef load_field_data():\n    \"\"\"Load field boundary data from database\"\"\"\n    try:\n        conn = sqlite3.connect('agricultural_data.db')\n        df = pd.read_sql_query(\n            \"\"\"\n            SELECT * FROM field_boundaries \n            WHERE coordinates IS NOT NULL AND coordinates != ''\n            ORDER BY creation_date DESC\n        \"\"\", conn)\n        conn.close()\n        return df\n    except Exception as e:\n        st.error(f\"Error loading field boundaries: {str(e)}\")\n        return pd.DataFrame()\n\n\n# Load data\nform_df = load_form_data()\nfield_df = load_field_data()\n\n# Overview metrics\nst.subheader(\"Data Overview\")\ncol1, col2, col3, col4, col5 = st.columns(5)\n\nwith col1:\n    st.metric(\"Form Responses\", len(form_df))\nwith col2:\n    st.metric(\"Field Boundaries\", len(field_df))\nwith col3:\n    if not field_df.empty:\n        total_mapped_area = field_df['area_estimate'].sum()\n        st.metric(\"Total Mapped Area (ha)\", f\"{total_mapped_area:.1f}\")\n    else:\n        st.metric(\"Total Mapped Area\", \"No data\")\nwith col4:\n    total_records = len(form_df) + len(field_df)\n    st.metric(\"Total Records\", total_records)\nwith col5:\n    if not form_df.empty and not field_df.empty:\n        st.metric(\"Data Status\", \"✅ Active\")\n    else:\n        st.metric(\"Data Status\", \"⚠️ Limited\")\n\n# Form Data Analysis\nif not form_df.empty:\n    col1, col2 = st.columns(2)\n\n    with col1:\n        # Quantity harvested distribution\n        if 'qty_harvested' in form_df.columns:\n            fig2 = px.histogram(form_df,\n                                x='qty_harvested',\n                                title=\"Quantity Harvested Distribution\",\n                                nbins=10,\n                                labels={\n                                    'qty_harvested': 'Quantity Harvested',\n                                    'count': 'Number of Records'\n                                })\n            st.plotly_chart(fig2, use_container_width=True)\n\n    with col2:\n        # Price vs Quantity relationship\n        if 'price_per_unit' in form_df.columns and 'qty_harvested' in form_df.columns:\n            fig4 = px.scatter(\n                form_df,\n                x='qty_harvested',\n                y='price_per_unit',\n                color='crop_type' if 'crop_type' in form_df.columns else None,\n                title=\"Price vs Quantity Harvested\",\n                labels={\n                    'qty_harvested': 'Quantity Harvested',\n                    'price_per_unit': 'Price per Unit'\n                })\n            st.plotly_chart(fig4, use_container_width=True)\n\n    # Recent submissions table\n    st.subheader(\"Recent Form Submissions\")\n    if len(form_df) > 0:\n        # Show last 10 submissions\n        recent_forms = form_df.head(10)\n        display_cols = [\n            'farmer_id', 'district', 'village', 'crop_type', 'season_year',\n            'submission_date'\n        ]\n        available_cols = [\n            col for col in display_cols if col in recent_forms.columns\n        ]\n\n        if available_cols:\n            st.dataframe(recent_forms[available_cols],\n                         use_container_width=True,\n                         hide_index=True)\n    else:\n        st.info(\"No form submissions yet.\")\n\nelse:\n    st.info(\n        \"📝 No form responses available. Visit the Form Collection page to add data.\"\n    )\n\n# Field Data Analysis\nif not field_df.empty:\n\n    # Field boundaries table\n    st.subheader(\"Recent Field Boundaries\")\n    display_cols = [\n        'field_name', 'field_type', 'area_estimate', 'creation_date'\n    ]\n    available_cols = [col for col in display_cols if col in field_df.columns]\n\n    if available_cols:\n        recent_fields = field_df.head(10)\n        st.dataframe(recent_fields[available_cols],\n                     use_container_width=True,\n                     hide_index=True)\n\nelse:\n    st.info(\n        \"🗺️ No field boundaries mapped yet. Visit the Field Mapping page to add boundaries.\"\n    )\n\n# Field Boundaries Map\nst.subheader(\"Field Boundaries Map\")\n\n# Create map centered on Upolu Island, Samoa\nmap_center = [-13.9167, -171.7500]  # Upolu Island coordinates\nm = folium.Map(location=map_center, zoom_start=10, tiles=None)\n\n# Add satellite tile layer\nfolium.TileLayer(\n    tiles=\n    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',\n    attr='Esri',\n    name='Satellite',\n    overlay=False,\n    control=True).add_to(m)\n\n# Add OpenStreetMap layer as backup\nfolium.TileLayer(tiles='OpenStreetMap',\n                 name='Street Map',\n                 overlay=False,\n                 control=True).add_to(m)\n\n# Define colors for field boundaries\ncolors = [\n    'red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige',\n    'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'white', 'pink',\n    'lightblue', 'lightgreen', 'gray', 'black', 'lightgray'\n]\n\n# Add all field boundaries to the map\nif not field_df.empty:\n    for idx, (_, row) in enumerate(field_df.iterrows()):\n        try:\n            # Check if coordinates exist and are not empty\n            if pd.isna(row['coordinates']) or str(\n                    row['coordinates']).strip() == '':\n                continue\n\n            coordinates = json.loads(str(row['coordinates']))\n\n            # Validate coordinates structure\n            if not coordinates or len(coordinates) < 3:\n                continue\n\n            # Convert coordinates to folium format [lat, lng]\n            folium_coords = [[coord[1], coord[0]] for coord in coordinates]\n\n            # Choose color based on field type or cycle through available colors\n            color = colors[idx % len(colors)]\n\n            # Safely get field attributes with defaults\n            field_name = row.get('field_name', 'Unknown Field')\n            field_type = row.get('field_type', 'Unknown')\n            crop_type = row.get('crop_type', 'Unknown')\n            area_estimate = row.get('area_estimate', 0)\n            creation_date = str(row.get('creation_date', ''))[:10]\n\n            # Add polygon to map\n            folium.Polygon(locations=folium_coords,\n                           popup=f\"\"\"\n                <b>{field_name}</b><br>\n                Type: {field_type}<br>\n                Crop: {crop_type}<br>\n                Area: {area_estimate} acres<br>\n                Created: {creation_date}\n                \"\"\",\n                           tooltip=f\"{field_name} ({field_type})\",\n                           color=color,\n                           weight=2,\n                           opacity=0.8,\n                           fillColor=color,\n                           fillOpacity=0.3).add_to(m)\n\n        except (json.JSONDecodeError, KeyError, TypeError, IndexError) as e:\n            # Silently skip invalid boundaries instead of showing warnings\n            continue\n\n# Add layer control\nfolium.LayerControl().add_to(m)\n\n# Display the map\nif not field_df.empty:\n    st_folium(m, width=\"100%\", height=500)\nelse:\n    st.info(\n        \"No field boundaries to display on map. Add boundaries from the Field Mapping page.\"\n    )\n\n# Export functionality\nst.subheader(\"📤 Data Export\")\ncol1, col2, col3 = st.columns(3)\n\nwith col1:\n    if not form_df.empty:\n        csv_form = form_df.to_csv(index=False)\n        st.download_button(\n            label=\"📄 Download Form Data (CSV)\",\n            data=csv_form,\n            file_name=f\"form_responses_{datetime.now().strftime('%Y%m%d')}.csv\",\n            mime=\"text/csv\")\n\nwith col2:\n    if not field_df.empty:\n        csv_field = field_df.to_csv(index=False)\n        st.download_button(\n            label=\"🗺️ Download Field Data (CSV)\",\n            data=csv_field,\n            file_name=\n            f\"field_boundaries_{datetime.now().strftime('%Y%m%d')}.csv\",\n            mime=\"text/csv\")\n\nwith col3:\n    if not form_df.empty or not field_df.empty:\n        # Combined summary report\n        summary_data = {\n            'metric': [\n                'Total Form Responses', 'Total Field Boundaries',\n                'Data Collection Date'\n            ],\n            'value':\n            [len(form_df),\n             len(field_df),\n             datetime.now().strftime('%Y-%m-%d')]\n        }\n        summary_df = pd.DataFrame(summary_data)\n        csv_summary = summary_df.to_csv(index=False)\n        st.download_button(\n            label=\"📊 Download Summary Report\",\n            data=csv_summary,\n            file_name=f\"summary_report_{datetime.now().strftime('%Y%m%d')}.csv\",\n            mime=\"text/csv\")\n\nst.markdown(\"---\")\n","size_bytes":11304}},"version":1}